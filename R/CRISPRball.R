#' Create an interactive Shiny app for visualization & exploration of MAGeCK RRA CRISPR analyses
#'
#' This shiny app is composed of multiple tabs to peruse RRA results and compare them between timepoints or samples.
#' Also included are numerous QC plots. Almost all plots are interactive and their aesthetics can be easily tweaked
#' using the sidebar. See the Details section for more information.
#'
#' Gene labels can be added to the MAplot and volcano plot by clicking a point. The labels can also be dragged around,
#' though adding labels will reset the positions, so it's recommended to add all labels prior to re-positioning them.
#'
#' @details Features with no variation will be removed prior to \code{\link[PCAtools]{pca}} being run for the PCA visualization.
#'
#' @rawNamespace import(shiny, except = c(dataTableOutput, renderDataTable))
#' @importFrom ComplexHeatmap Heatmap pheatmap
#' @import DT
#' @importFrom plotly ggplotly plotlyOutput renderPlotly toWebGL plot_ly layout add_annotations config toRGB event_data
#' @import ggplot2
#' @importFrom shinyWidgets prettyCheckbox dropdownButton tooltipOptions pickerInput
#' @importFrom shinycssloaders withSpinner
#' @importFrom shinyjqui jqui_resizable
#' @importFrom shinyjs show useShinyjs hidden disable click extendShinyjs js
#' @importFrom shinyBS tipify popify
#' @importFrom colourpicker colourInput
#' @importFrom MAGeCKFlute BarView MapRatesView
#' @importFrom PCAtools pca
#' @importFrom dittoSeq dittoColors
#' @importFrom grid grid.newpage grid.text
#' @importFrom matrixStats rowVars rowMaxs rowMins
#' @importFrom graphics hist legend lines
#' @importFrom stats cor
#' @importFrom utils read.csv
#'
#' @param gene.data A named list containing \code{gene_summary.txt} tables as data.frames.
#'   Multiple data.frames may be provided, one per element of the list.
#'   Users will be able to swap between them within the app. List element names should match names of \code{grna.data} list elements.
#' @param sgrna.data A named list containing \code{sgrna_summary.txt} tables as data.frames.
#'   Multiple data.frames may be provided, one per element of the list.
#'   Users will be able to swap between them within the app. List element names should match names of \code{gene.data} list elements.
#' @param count.summary Matrix or dataframe containing count summary (\code{countsummary.txt}) as generated by \code{mageck count}.
#' @param norm.counts Matrix or dataframe containing normalized counts (\code{count_normalized.txt}) as generated by \code{mageck count}.
#' @param h.id String indicating unique ID for interactive plots.
#'   Required if multiple apps are run within the same Rmd file.
#' @param positive.ctrl.genes Optional character vector of gene identifiers for
#'   positive control genes from the screen so that they can be easily filtered.
#' @param essential.genes Optional character vector of gene identifiers of common
#'   essential genes (i.e. pan-lethal) so that they can be easily filtered.
#'   If provided, overrides the depmap essential genes.
#' @param depmap.db Optional character scalar for name of SQLite database returned by \code{\link{build_depmap_db}}.
#' @param genesets Optional named list containing genesets that can be interactively highlighted on the plots.
#'   The elements of the list should each be a geneset with gene identifiers matching those used in the results.
#' @param return.app Optional boolean indicating whether a Shiny app should be returned. \code{TRUE} by default. If \code{FALSE},
#'   a named list of app elements (ui and server) will be returned instead. Useful for deploying as a standalone shiny app.
#'
#' @return A Shiny app containing interactive visualizations of MAGeCK RRA analysis results.
#'
#'
#' @author Jared Andrews
#' @export
CRISPRball <- function(gene.data = NULL, sgrna.data = NULL, count.summary = NULL, norm.counts = NULL, h.id = "mag1",
                       positive.ctrl.genes = NULL, essential.genes = NULL,
                       depmap.db = NULL, genesets = NULL, return.app = TRUE) {

  # Increase file upload size limit to 50MB, which should cover pretty much any use case.
  options(shiny.maxRequestSize = 50*1024^2)
  
  # Set initial metadata and dataset choices if input data isn't NULL.
  gene.choices <- NULL
  sgrna.choices <- NULL
  summ.choices <- NULL
  
  if (!is.null(gene.data)) {
    gene.choices <- names(gene.data)
  }
  
  if (!is.null(sgrna.data)) {
    sgrna.choices <- names(sgrna.data)
  }
  
  if (!is.null(count.summary)) {
    summ.choices <- colnames(count.summary)
  }
  
  # Load cell line metadata and gene summaries if depmap db provided.
  if (!is.null(depmap.db)) {
    .error_if_no_pool()
    .error_if_no_rsqlite()

    pool <- pool::dbPool(RSQLite::SQLite(), dbname = depmap.db)
    depmap.meta <- pool::dbGetQuery(pool, "SELECT * FROM 'meta'")
    depmap.gene <- pool::dbGetQuery(pool, "SELECT * FROM 'gene.summary'")

    # Close db on app close.
    onStop(function() {pool::poolClose(pool)})
  } else {
    depmap.meta <- NULL
    depmap.gene <- NULL
  }

  ui <- navbarPage(
    "CRISPRball",
    useShinyjs(),
    extendShinyjs(text=.utils.js, functions = c('disableTab','enableTab')),
    tags$head(
      # Note the wrapping of the string in HTML()
      tags$style(HTML("
          .panel-body {
            padding: 5px;
          }
          .form-group {
            margin-bottom: 3px;
            padding-bottom: 2px !important;
            padding-top: 2px !important;
            font-size: 10px;
            line-height: 1.1;
          }
          .well {
            padding: 5px;
            margin-bottom: 10px;
          }
          .form-control, .selectize-input {
            padding-bottom: 2px !important;
            padding-top: 2px !important;
            font-size: 10px;
            height: 24px;
            min-height: 24px;
            line-height: 1.1;
          }
          .control-label {
            font-size: 10px;
            margin-bottom: 2px;
          }
          .panel-heading {
            padding: 5px 10px;
          }
          .selectize-control {
            margin-bottom: 0px;
          }
          body {
            line-height: 1.1;
          }
          hr{
            margin-top: 3px;
            margin-bottom: 3px;
          }
          .panel-group {
            margin-bottom: 8px;
          }
          h3 {
            margin-top: 0px;
          }
          .nav li a.disabled {
            background-color: #aaa !important;
            color: #333 !important;
            cursor: not-allowed !important;
            border-color: #aaa !important;
          }
        "))
    ),
    tabPanel(
      title = "Data Upload",
      id = "upload",
      wellPanel(
        h3("Count Files"),
        fileInput("countNormFile", "Choose Normalized Count File", multiple=FALSE, accept = ".txt"),
        fileInput("countSummary", "Choose Count Summary File", multiple=FALSE, accept = ".txt"),
      ),
      br(),
      wellPanel(
        h3("Gene and sgRNA Summary Files"),
        fileInput("geneSummaryFiles", "Choose Gene Summary File(s)", multiple=TRUE, accept = ".txt"),
        fileInput("sgrnaSummaryFiles", "Choose sgRNA Summary File(s)", multiple=TRUE, accept = ".txt"),
      ),
    ),
    tabPanel(title = "QC",
             id = "qc",
             sidebarLayout(
               sidebarPanel(
                 width = 2,
                 h4("Plot Controls"),
                 hr(),
                 bsCollapse(open = "pca.settings",
                            bsCollapsePanel(
                              title = span(icon("plus"), "PCA Settings"), value = "pca.settings", style = "info",
                              uiOutput("pca.comps"),
                              conditionalPanel(
                                condition = "input['keep.top.n'] == false",
                                numericInput("var.remove", "Remove this proportion of features ranked by variance:",
                                             min = 0, max = 1, step = 0.01, value = 0)
                              ),
                              conditionalPanel(
                                condition = "input['keep.top.n'] == true",
                                numericInput("var.n.keep", "Number of features to retain by variance:",
                                             min = 2, max = Inf, step = 1, value = 500)
                              ),
                              fluidRow(
                                column(6,
                                       tipify(prettyCheckbox("center", strong("Center data"), TRUE, bigger = FALSE,
                                                             animation = "smooth", status = "success",
                                                             icon = icon("check"), width = "100%"),
                                              "Zero center the data before performing PCA.", "right", options = list(container = "body")),
                                       tipify(prettyCheckbox("keep.top.n", strong("Limit by top N features"), FALSE, bigger = FALSE,
                                                             animation = "smooth", status = "success",
                                                             icon = icon("check"), width = "100%"),
                                              "Limit PCA to top N features ranked by variance.", "right", options = list(container = "body"))
                                ),
                                column(6,
                                       tipify(prettyCheckbox("scale", strong("Scale data"), TRUE, bigger = FALSE,
                                                             animation = "smooth", status = "success",
                                                             icon = icon("check"), width = "100%"),
                                              "Scale the data to have unit variance before performing PCA.", "right", options = list(container = "body"))
                                )
                              ),
                              tipify(prettyCheckbox("meta.filt", strong("Filter via metadata table"), TRUE, bigger = FALSE,
                                                    animation = "smooth", status = "success",
                                                    icon = icon("check"), width = "100%"),
                                     "Filter PCA samples to those in metadata table.", "right", options = list(container = "body")),
                              fluidRow(
                                column(6, tipify(selectizeInput("bip.color", "Color by:",
                                                                choices = summ.choices),
                                                 "Metadata variable by which samples are colored.", "right", options = list(container = "body"))),
                                column(6, tipify(selectizeInput("bip.shape", "Shape by:",
                                                                choices = summ.choices),
                                                 "Metadata variable by which samples are shaped.", "right", options = list(container = "body")))
                              ),
                              fluidRow(
                                column(6,
                                       tipify(prettyCheckbox("bip.twod", strong("Limit to 2D"), TRUE, bigger = FALSE,
                                                             animation = "smooth", status = "success",
                                                             icon = icon("check"), width = "100%"),
                                              "Limit PCA biplot to 2D.", "right", options = list(container = "body"))
                                ),
                                column(6,
                                       tipify(prettyCheckbox("bip.loadings", strong("Plot Loadings"), FALSE, bigger = FALSE,
                                                             animation = "smooth", status = "success",
                                                             icon = icon("check"), width = "100%"),
                                              "Plot top PCA loadings for each PC.", "right", options = list(container = "body")
                                       )
                                ),
                                column(12,
                                  tipify(numericInput("bip.n.loadings", "Loadings:",
                                                      min = 0, max = 100, step = 1, value = 5),
                                         "Number of PCA loadings to plot (if checked).", "right", options = list(container = "body")
                                  )
                                ),
                                div(actionButton("pca.update", "Update PCA"), align = "center")
                              )
                            )
                 )
               ),
               mainPanel(
                 width = 10,
                 fluidRow(
                   column(width = 4,
                          span(popify(icon("info-circle", style="font-size: 20px"), "Gini Index",
                                      c("This plot shows the gini index for each sample, ",
                                        "which is a measure of read count inequality between guides. ",
                                        "For initial timepoints and early passages, this should usually be <0.1, ",
                                        "but should increase as selection occurs."),
                                      placement = "bottom", trigger = "hover", options = list(container = "body")),
                               jqui_resizable(plotlyOutput("qc.gini"))),
                          span(popify(icon("info-circle", style="font-size: 20px"), "Read Distributions",
                                      c("This plot shows the read distribution across guides for each sample. ",
                                        "The distribution should be normal and relatively tight for initial ",
                                        "timepoints and early passages. As selection occurs, the ",
                                        "distribution will begin to spread, and there may be buildup at the extremes."),
                                      placement = "top", trigger = "hover", options = list(container = "body")),
                               jqui_resizable(plotOutput("qc.histplot")))
                   ),
                   column(width = 4,
                          span(popify(icon("info-circle", style="font-size: 20px"), "Zero Count gRNAs",
                                      c("This plot shows the number of guides with zero reads for each sample. ",
                                        "For early passages and initial timepoints, this count should ideally be zero ",
                                        "but should increase as selection occurs. Useful for assessing library quality."),
                                      placement = "bottom", trigger = "hover", options = list(container = "body")),
                               jqui_resizable(plotlyOutput("qc.missed"))),
                          span(popify(icon("info-circle", style="font-size: 20px"), "Sample Correlations",
                                      c("This plot shows correlation between samples. Typically, initial timepoints ",
                                        "and early passages, even from different tissues or conditions, correlate well, ",
                                        "but diverge more and more as selection occurs."),
                                      placement = "top", trigger = "hover", options = list(container = "body")),
                               jqui_resizable(plotOutput("qc.corr")))
                   ),
                   column(width = 4,
                          span(popify(icon("info-circle", style="font-size: 20px"), "Mapping Rates",
                                      c("This plot shows read mapping rates for each sample. 50-75% mapped is typical."),
                                      placement = "bottom", trigger = "hover", options = list(container = "body")),
                               jqui_resizable(plotOutput("qc.map"))),
                          span(popify(icon("info-circle", style="font-size: 20px"), "Principal Componenet Analysis",
                                      c("This biplot shows two (or three) PCs from a principal component analysis. ",
                                        "For initial timepoints, libraries should be nearly identical, even for different tissues or cell lines. ",
                                        "As selection occurs, samples should diverge."),
                                      placement = "top", trigger = "hover", options = list(container = "body")),
                               withSpinner(jqui_resizable(plotlyOutput("qc.pca")))),
                   )
                 )
               )
             )
    ),
    tabPanel(title = "QC Table",
             id = "qc-table",
             br(),
             DTOutput("count.summary")
    ),
    tabPanel(title = "Gene (Overview)",
             id = "gene-overview",
             sidebarLayout(
               sidebarPanel(
                 width = 2,
                 h4("Plot Controls"),
                 hr(),
                 div(
                   fluidRow(
                     column(6,
                            tipify(selectizeInput("gene.sel1", "Dataset 1:", choices = gene.choices),
                                   "Dataset shown in top row.", "right", options = list(container = "body")),
                            numericInput("gene.fdr.th", "FDR threshold:",
                                         min = 0, max = 1, step = 0.01, value = 0.05)
                     ),
                     column(6,
                            tipify(selectizeInput("gene.sel2", "Dataset 2:", choices = gene.choices),
                                   "Dataset shown in bottom row.", "right", options = list(container = "body")),
                            numericInput("gene.lfc.th", "log2FC threshold:",
                                         min = 0, max = Inf, step = 0.05, value = 0.5)
                     )
                   ),
                   fluidRow(
                     column(12,
                            tipify(prettyCheckbox("rem.ess", label = "Remove essential genes", value = FALSE,
                                                  animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                                   "Remove essential genes if any provided to function.", "right", options = list(container = "body")),
                            tipify(prettyCheckbox("dep.crispr.ess", label = "Remove DepMap CRISPR essential genes", value = FALSE,
                                                  animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                                   "Remove DepMap Chronos Combined, Score, and Achilles common essential genes from latest release.",
                                   "right", options = list(container = "body")),
                            tipify(prettyCheckbox("dep.rnai.ess", label = "Remove DepMap RNAi essential genes", value = FALSE,
                                                  animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                                   "Remove RNAi common essential genes from latest DepMap release.", "right", options = list(container = "body")),
                            tipify(prettyCheckbox("dep.crispr.sel", label = "Remove DepMap CRISPR selective genes", value = FALSE,
                                                  animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                                   "Remove DepMap Chronos Combined, Score, and Achilles strongly selective genes from latest release.", "right",
                                   options = list(container = "body")),
                            tipify(prettyCheckbox("dep.rnai.sel", label = "Remove DepMap RNAi selective genes", value = FALSE,
                                                  animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                                   "Remove DepMap RNAi strongly selective genes from latest release.", "right", options = list(container = "body")),
                            tipify(prettyCheckbox("rem.pos", label = "Remove positive control genes", value = FALSE,
                                                  animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                                   "Remove positive control genes if provided to function.", "right", options = list(container = "body")),
                            tipify(prettyCheckbox("highlight.common", label = "Highlight common hits", value = FALSE,
                                                  animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                                   "Highlight common hits between datasets.", "right", options = list(container = "body"))
                     )
                   ),
                   style = "background-color: #FFFFFF; padding: 3px; margin-bottom: 3px; border: 1px solid #bce8f1; "),
                 bsCollapse(open = NULL,
                            bsCollapsePanel(
                              title = span(icon("plus"), "Common Plot Settings"), value = "com.settings", style = "info",
                              fluidRow(
                                column(width = 6,
                                       tipify(colourInput("down.color", "Down colour", value = "#0026ff"),
                                              "Color of negatively selected genes.", "right", options = list(container = "body")),
                                       tipify(colourInput("up.color", "Up colour", value = "red"),
                                              "Color of positively selected genes.", "right", options = list(container = "body")),
                                       tipify(colourInput("insig.color", "Insig colour", value = "#A6A6A6"),
                                              "Color of insignificant genes.", "right", options = list(container = "body")),
                                       tipify(numericInput("sig.opa", label = "Sig opacity:", value = 1, step = 0.05, min = 0),
                                              "Opacity of significantly selected genes.", "right", options = list(container = "body"))
                                ),
                                column(width = 6,
                                       tipify(numericInput("sig.size", label = "Sig pt size:", value = 6, step = 0.1, min = 0),
                                              "Point size of significantly selected genes.", "right", options = list(container = "body")),
                                       tipify(numericInput("lab.size", label = "Label size:", value = 10, step = 0.5, min = 1),
                                              "Label size of significantly selected genes.", "right", options = list(container = "body")),
                                       tipify(numericInput("insig.opa", label = "Insig opacity:", value = 0.5, step = 0.05, min = 0),
                                              "Opacity of insignificant genes.", "right", options = list(container = "body")),
                                       tipify(numericInput("insig.size", label = "Insig pt size:", value = 5, step = 0.1, min = 0),
                                              "Point size of insignificant genes.", "right", options = list(container = "body"))
                                )
                              ),
                              splitLayout(
                                tipify(prettyCheckbox("counts", label = "Show counts", TRUE, bigger = TRUE,
                                                      animation = "smooth", status = "success",
                                                      icon = icon("check"), width = "100%"),
                                       "Show hit counts on plot.", "right", options = list(container = "body")),
                                tipify(prettyCheckbox("webgl", label = "Use webGL", FALSE, bigger = TRUE,
                                                      animation = "smooth", status = "success",
                                                      icon = icon("check"), width = "100%"),
                                       "Use webGL for plot generation (faster to update, sometimes has visual artifacts).", "right", options = list(container = "body"))
                              ),
                              splitLayout(
                                tipify(prettyCheckbox("hl.counts", label = "Show highlight counts", FALSE, bigger = TRUE,
                                                      animation = "smooth", status = "success",
                                                      icon = icon("check"), width = "100%"),
                                       "Show highlighted gene counts on plot.", "right", options = list(container = "body"))
                              ),
                              splitLayout(
                                tipify(numericInput("counts.size", label = "Counts size:", value = 8, step = 0.1, min = 0),
                                       "Size of counts text.", "right", options = list(container = "body")),
                                tipify(numericInput("webgl.ratio", label = "webGL pixel ratio:", value = 7, step = 0.1, min = 1),
                                       "webGL rasterization ratio. Recommend leaving this alone for high-res rasterization.", "right", options = list(container = "body"))
                              )
                            ),
                            bsCollapsePanel(
                              title = span(icon("plus"), "Volcano Plot Settings"), value = "vol.settings", style = "info",
                              fluidRow(
                                column(width = 6,
                                       numericInput("vol.x", label = "x-axis limits:", value = 5, step = 0.1, min = 0.1)
                                ),
                                column(width = 6,
                                       numericInput("vol.y", label = "y-axis limits:", value = 5, step = 0.5, min = 1)
                                )
                              ),
                              splitLayout(
                                prettyCheckbox("vol.fcline", label = "Show FC threshold", value = TRUE,
                                               animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                                prettyCheckbox("vol.sigline", label = "Show Sig. threshold", value = TRUE,
                                               animation = "smooth", status = "success", bigger = TRUE, icon = icon("check"))
                              ),
                              div(actionButton("vol.update", "Update Volcano Plots"), align = "center")
                            ),
                            bsCollapsePanel(
                              title = span(icon("plus"), "Rank Plot Settings"), value = "rank.settings", style = "info",
                              fluidRow(
                                column(width = 6,
                                       numericInput("rank.y.max", label = "y-axis max:", value = 2, step = 0.5),
                                       prettyCheckbox("rank.fcline", label = "Show FC threshold", value = TRUE,
                                                      animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                                ),
                                column(width = 6,
                                       numericInput("rank.y.min", label = "y-axis min:", value = -10, step = 0.5, min = 1),
                                )
                              ),
                              div(actionButton("rank.update", "Update Rank Plots"), align = "center")
                            ),
                            bsCollapsePanel(
                              title = span(icon("plus"), "Lawn Plot Settings"), value = "lawn.settings", style = "info",
                              splitLayout(
                                prettyCheckbox("lawn.sigline", label = "Show Sig. threshold", value = TRUE,
                                               animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                                numericInput("lawn.y", label = "y-axis limits:", value = 5, step = 0.5, min = 1)
                              ),
                              div(actionButton("lawn.update", "Update Lawn Plots"), align = "center")
                            ),
                            bsCollapsePanel(title = span(icon("plus"), "Highlight Gene(sets)"), value = "highlight.settings", style = "info",
                                            tipify(textAreaInput("hl.genes", "Highlight Genes:", value = "", rows = 4,
                                                                 placeholder = "Enter space, comma, or newline delimited genes"),
                                                   "Genes to highlight on plots.", "right", options = list(container = "body")),
                                            tipify(pickerInput("hl.genesets", "Highlight Genesets:", choices = c("", names(genesets)),
                                                               multiple = TRUE, options = list(`live-search` = TRUE, `actions-box` = TRUE)),
                                                   "If provided, genesets available to highlight on plots.", "right", options = list(container = "body")),
                                            fluidRow(
                                              column(6,
                                                     tipify(numericInput("hl.genes.opa", label = "Genes opacity:", value = 1, step = 0.05, min = 0),
                                                            "Opacity of highlighted genes.", "right", options = list(container = "body")),
                                                     tipify(numericInput("hl.genes.size", label = "Genes pt size:", value = 7, step = 0.1, min = 0),
                                                            "Point size of highlighted genes.", "right", options = list(container = "body")),
                                                     tipify(numericInput("hl.genes.lw", label = "Genes border width:", value = 1, step = 0.05, min = 0),
                                                            "Border width of highlighted genes.", "right", options = list(container = "body")),
                                                     tipify(colourInput("hl.genes.col", "Genes color:", value = "#E69F00"),
                                                            "Fill color of highlighted genes.", "right", options = list(container = "body")),
                                                     tipify(colourInput("hl.genes.lcol", "Genes border:", value = "#000000"),
                                                            "Border color of highlighted genes.", "right", options = list(container = "body")))
                                              ,
                                              column(6,
                                                     tipify(numericInput("hl.genesets.opa", label = "Sets opacity:", value = 1, step = 0.05, min = 0),
                                                            "Opacity of genes in highlighted geneset(s).", "right", options = list(container = "body")),
                                                     tipify(numericInput("hl.genesets.size", label = "Sets pt size:", value = 7, step = 0.1, min = 0),
                                                            "Point size of genes in highlighted geneset(s).", "right", options = list(container = "body")),
                                                     tipify(numericInput("hl.genesets.lw", label = "Sets border width:", value = 1, step = 0.05, min = 0),
                                                            "Border width genes in of highlighted geneset(s).", "right", options = list(container = "body")),
                                                     tipify(colourInput("hl.genesets.col", "Sets color:", value = "#009E73"),
                                                            "Fill color of genes in highlighted geneset(s).", "right", options = list(container = "body")),
                                                     tipify(colourInput("hl.genesets.lcol", "Sets border:", value = "#000000"),
                                                            "Border color of genes in highlighted geneset(s).", "right", options = list(container = "body")))
                                            )
                            )
                 ),
                 div(actionButton("gene.update", "Update Plots"), align = "center")
               ),
               mainPanel(
                 width = 10,
                 fluidRow(
                   column(width = 4,
                          span(popify(icon("info-circle", style="font-size: 20px"), title = "Volcano Plot",
                                      c("This volcano plot shows the log2 fold change on the x-axis and the -log10(FDR) value on the y-axis. ",
                                        "Thresholds are adjustable. Gene labels can be added (or removed) by clicking on a point ",
                                        "and can be moved by clicking and dragging the label. The plot is fully customizable with the settings on the left. ",
                                        "Click and drag to zoom in. Hover over a point for additional info.",
                                        "Genes with full sgRNA depletion tend to all have the same significance value, forming a shelf-like max y-axis value."),
                                      placement = "bottom", trigger = "hover", options = list(container = "body")),
                               withSpinner(jqui_resizable(plotlyOutput("gene1.vol"))))
                   ),
                   column(width = 4,
                          span(popify(icon("info-circle", style="font-size: 20px"), title = "Rank Plot",
                                      c("This rank plot shows the log2 fold change on the y-axis and the gene rank on the x-axis. ",
                                        "Thresholds are adjustable. Gene labels can be added (or removed) by clicking on a point ",
                                        "and can be moved by clicking and dragging the label. The plot is fully customizable with the settings on the left. ",
                                        "Click and drag to zoom in. Hover over a point for additional info."),
                                      placement = "bottom", trigger = "hover", options = list(container = "body")),
                               withSpinner(jqui_resizable(plotlyOutput("gene1.rank"))))
                   ),
                   column(width = 4,
                          span(popify(icon("info-circle", style="font-size: 20px"), title = "Lawn Plot",
                                      c("This plot shows the log2 fold change on the y-axis and the genes randomly ordered on the x-axis. ",
                                        "Thresholds are adjustable. Gene labels can be added (or removed) by clicking on a point ",
                                        "and can be moved by clicking and dragging the label. The plot is fully customizable with the settings on the left. ",
                                        "Click and drag to zoom in. Hover over a point for additional info."),
                                      placement = "bottom", trigger = "hover", options = list(container = "body")),
                               withSpinner(jqui_resizable(plotlyOutput("gene1.lawn"))))
                   )
                 ),
                 hr(),
                 fluidRow(
                   column(width = 4,
                          withSpinner(jqui_resizable(plotlyOutput("gene2.vol")))
                   ),
                   column(width = 4,
                          withSpinner(jqui_resizable(plotlyOutput("gene2.rank")))
                   ),
                   column(width = 4,
                          withSpinner(jqui_resizable(plotlyOutput("gene2.lawn")))
                   )
                 )
               )
             )
    ),
    tabPanel(title = "Gene Summary Tables",
             id = 'gene-summ',
             br(),
             div(DT::dataTableOutput("gene1.summary"), style = "font-size:80%;"),
             br(),
             div(DT::dataTableOutput("gene2.summary"), style = "font-size:80%;")
    ),
    tabPanel(title = "sgRNA",
             id = 'sgrna',
             sidebarLayout(
               sidebarPanel(
                 width = 2,
                 h4("Plot Controls"),
                 hr(),
                 div(
                   fluidRow(
                     column(6,
                            tipify(selectizeInput("sgrna.sel1", "Dataset 1:", choices = sgrna.choices),
                                   "Dataset shown in top row.", "right", options = list(container = "body"))
                     ),
                     column(6,
                            tipify(selectizeInput("sgrna.sel2", "Dataset 2:", choices = sgrna.choices),
                                   "Dataset shown in bottom row.", "right", options = list(container = "body"))
                     )
                   ),
                   fluidRow(
                     column(12,
                            pickerInput("sgrna.gene", "Choose gene:", choices = unique(c(sgrna.data[[1]]$Gene)),
                                        multiple = FALSE, options = list(`live-search` = TRUE, `actions-box` = TRUE))
                     )
                   ),
                   style = "background-color: #FFFFFF; padding: 3px; margin-bottom: 3px; border: 1px solid #bce8f1; "),
               ),
               mainPanel(
                 width = 10,
                 fluidRow(
                   column(width = 2,
                          span(popify(icon("info-circle", style="font-size: 20px"), title = "Counts Plot",
                                      c("This rank plot shows the normalized counts for each sgRNA for the ",
                                        "specified gene across the samples that make up the dataset comparision. ",
                                        "Hover over a point for additional info."),
                                      placement = "bottom", trigger = "hover", options = list(container = "body")),
                               withSpinner(jqui_resizable(plotlyOutput("sgrna1.counts"))))
                   ),
                   column(width = 4,
                          span(popify(icon("info-circle", style="font-size: 20px"), title = "Rank Plot",
                                      c("This rank plot shows the log2 fold change on the y-axis and the sgRNA rank on the x-axis. ",
                                        "sgRNAs for the selected gene will be highlighted. ",
                                        "Click and drag to zoom in. Hover over a point for additional info."),
                                      placement = "bottom", trigger = "hover", options = list(container = "body")),
                               withSpinner(jqui_resizable(plotlyOutput("sgrna1.rank"))))
                   ),
                   column(width = 6,
                          jqui_resizable(div(DT::dataTableOutput("sgrna1.detail"), style = "font-size:80%;"))
                   )
                 ),
                 hr(),
                 fluidRow(
                   column(width = 2,
                          withSpinner(jqui_resizable(plotlyOutput("sgrna2.counts")))
                   ),
                   column(width = 4,
                          withSpinner(jqui_resizable(plotlyOutput("sgrna2.rank")))
                   ),
                   column(width = 6,
                          jqui_resizable(div(DT::dataTableOutput("sgrna2.detail"), style = "font-size:80%;"))
                   )
                 )
               )
             )
    ),
    tabPanel(title = "sgRNA Summary Tables",
             id = 'sgrna-tables',
             br(),
             div(DT::dataTableOutput("sgrna1.summary"), style = "font-size:80%;"),
             br(),
             div(DT::dataTableOutput("sgrna2.summary"), style = "font-size:80%;")
    ),
    tabPanel(title = "DepMap",
             id = 'depmap',
             sidebarLayout(
               sidebarPanel(
                 width = 2,
                 h4("Plot Controls"),
                 hr(),
                 div(
                   fluidRow(
                     column(12,
                            pickerInput("depmap.gene", "Choose gene:", choices = unique(c(sgrna.data[[1]]$Gene)),
                                        multiple = FALSE, options = list(`live-search` = TRUE, `actions-box` = TRUE))
                     )
                   ),
                   style = "background-color: #FFFFFF; padding: 3px; margin-bottom: 3px; border: 1px solid #bce8f1; "),

               ),
               mainPanel(
                 width = 10,
                 fluidRow(
                   column(width = 4,
                          span(h3("Dependent Cell Lines", popify(icon("info-circle", style="font-size: 20px"), "Dependent Cell Lines",
                                                                 c("This plot shows DepMap dependency scores for the selected gene. ",
                                                                   "A cell line is considered dependent if it has a probability of dependency ",
                                                                   "greater than 50%. <br><br>",
                                                                   "Probabilities of dependency are calculated for each gene score in a cell ",
                                                                   "line as the probability that score arises from the distribution of essential ",
                                                                   "gene scores rather than nonessential gene scores.",
                                                                   "See the <a href=https://www.biorxiv.org/content/10.1101/720243v1>DepMap preprint</a> ",
                                                                   "for more info. <br><br>",
                                                                   "<b>Gene Effect</b><br>",
                                                                   "Outcome from <a href=https://www.nature.com/articles/s41467-018-06916-5>DEMETER2</a>",
                                                                   " or <a href=https://www.biorxiv.org/content/10.1101/2021.02.25.432728v1>Chronos</a>. ",
                                                                   "A lower score means that a gene is more likely to be dependent in a given cell line. ",
                                                                   "A score of 0 is equivalent to a gene that is not essential whereas a score of -1 corresponds ",
                                                                   "to the median of all common essential genes."),
                                                                 placement = "bottom", trigger = c("hover", "click"), options = list(container = "body")), .noWS="outside"),
                               uiOutput("depmap.deplines"),
                               jqui_resizable(plotlyOutput("depmap.essplot", height = 250))),

                          span(h3("Expression", popify(icon("info-circle", style="font-size: 20px"), "Gene Expression",
                                                       c("RNASeq files are aligned with STAR and quantified with RSEM, then TPM-normalized. ",
                                                         "Reported values are log2(TPM+1)."),
                                                       placement = "bottom", trigger = "hover", options = list(container = "body")), .noWS="outside"),
                               jqui_resizable(plotlyOutput("depmap.expplot", height = 200))),
                          span(h3("Copy Number", popify(icon("info-circle", style="font-size: 20px"), "Copy Number",
                                                        c("The <a href=https://forum.depmap.org/t/what-is-relative-copy-number-copy-number-ratio/104/2 target=_blank>relative ",
                                                          "copy number</a> pipeline used varies by cell line. For around 1000 lines, Sanger WES data ",
                                                          "was used, while for around 700 lines, Broad WES data was used. The remaining lines use SNP ",
                                                          "array data as explained in <a href=https://doi.org/10.1038/s41586-019-1186-3 target=_blank rel=noopener>",
                                                          "10.1038/s41586-019-1186-3</a>. See <a href=https://doi.org/10.1101/720243 target=_blank ",
                                                          "rel=noopener>10.1101/720243</a> for details on how CN source is chosen per line. Lines with ",
                                                          "WES data were processed through GATK using PONs from TCGA without matched normals and transformed by log2(x+1)."),
                                                        placement = "bottom", trigger = c("hover", "click"), options = list(container = "body")), .noWS="outside"),
                               jqui_resizable(plotlyOutput("depmap.cnplot", height = 200)))
                   ),
                   column(width = 4,
                          span(h3("Copy Number", popify(icon("info-circle", style="font-size: 20px"), "Copy Number",
                                                        c("The <a href=https://forum.depmap.org/t/what-is-relative-copy-number-copy-number-ratio/104/2 target=_blank>relative ",
                                                          "copy number</a> pipeline used varies by cell line. For around 1000 lines, Sanger WES data ",
                                                          "was used, while for around 700 lines, Broad WES data was used. The remaining lines use SNP ",
                                                          "array data as explained in <a href=https://doi.org/10.1038/s41586-019-1186-3 target=_blank rel=noopener>",
                                                          "10.1038/s41586-019-1186-3</a>. See <a href=https://doi.org/10.1101/720243 target=_blank ",
                                                          "rel=noopener>10.1101/720243</a> for details on how CN source is chosen per line. Lines with ",
                                                          "WES data were processed through GATK using PONs from TCGA without matched normals and transformed by log2(x+1)."),
                                                        placement = "bottom", trigger = c("hover", "click"), options = list(container = "body")), .noWS="outside"),
                               jqui_resizable(plotlyOutput("depmap.cnnplot", height = 350))),
                          span(popify(icon("info-circle", style="font-size: 20px"), "Sample Correlations",
                                      c("This plot shows correlation between samples. Typically, initial timepoints ",
                                        "and early passages, even from different tissues or conditions, correlate well, ",
                                        "but diverge more and more as selection occurs."),
                                      placement = "top", trigger = "hover", options = list(container = "body")),
                               jqui_resizable(plotOutput("depmap.corr", height = 350)))
                   ),
                   column(width = 4,
                          span(popify(icon("info-circle", style="font-size: 20px"), "Mapping Rates",
                                      c("This plot shows read mapping rates for each sample. 50-75% mapped is typical."),
                                      placement = "bottom", trigger = "hover", options = list(container = "body")),
                               jqui_resizable(plotOutput("depmap.map", height = 300))),
                          span(popify(icon("info-circle", style="font-size: 20px"), "Principal Componenet Analysis",
                                      c("This biplot shows two (or three) PCs from a principal component analysis. ",
                                        "For early passages and initial timepoints, this count should ideally be zero ",
                                        "but should increase as selection occurs. Useful for assessing library quality."),
                                      placement = "top", trigger = "hover", options = list(container = "body")),
                               withSpinner(jqui_resizable(plotlyOutput("depmap.pca", height = 300))))
                   )
                 )
               )
             )
    )
  )

  server <- function(input, output, session) {

    # --------------Disable Tabs-----------------
    defaultDisabledTabs <- c()

    if (is.null(gene.data)) {
      defaultDisabledTabs <- c(defaultDisabledTabs, "Gene (Overview)", "Gene Summary Tables")
    }

    if (is.null(sgrna.data)) {
      defaultDisabledTabs <- c(defaultDisabledTabs, "sgRNA", "sgRNA Summary Tables")
    }

    if (is.null(count.summary) | is.null(norm.counts)) {
      defaultDisabledTabs <- c(defaultDisabledTabs, "QC", "QC Table")
    }

    for (tabname in defaultDisabledTabs) {
      js$disableTab(tabname)
    }

    # -------------Reactive Values---------------

    gene.data <- reactiveVal(gene.data)
    sgrna.data <- reactiveVal(sgrna.data)
    count.summary <- reactiveVal(count.summary)
    norm.counts <- reactiveVal(norm.counts)


    # -----------Loading Files In----------------

    observeEvent(input$geneSummaryFiles, {
      new.data <- .gene_summ_ingress(input$geneSummaryFiles)
      gene.data(new.data)
      if (!is.null(gene.data())) {
        js$enableTab('Gene (Overview)')
        js$enableTab('Gene Summary Tables')
        updateSelectizeInput(session, 'gene.sel1', choices = names(gene.data()), server = TRUE)
        updateSelectizeInput(session, 'gene.sel2', choices = names(gene.data()), server = TRUE)
      }
    })

    observeEvent(input$sgrnaSummaryFiles, {
      new.data <- .sgrna_summ_ingress(input$sgrnaSummaryFiles)
      sgrna.data(new.data)
      if (!is.null(sgrna.data())) {
        js$enableTab('sgRNA')
        js$enableTab('sgRNA Summary Tables')
        updateSelectizeInput(session, 'sgrna.sel1', choices = names(sgrna.data()), server = TRUE)
        updateSelectizeInput(session, 'sgrna.sel2', choices = names(sgrna.data()), server = TRUE)
        if (!is.null(depmap.db)) {
          updateSelectizeInput(session, 'depmap.sel1', choices = names(sgrna.data()), server = TRUE)
          updateSelectizeInput(session, 'depmap.sel2', choices = names(sgrna.data()), server = TRUE)
        }
      }
    })

    observeEvent(input$countSummary, {
      new.data <- read.delim(input$countSummary$datapath)
      count.summary(new.data)
      if (!is.null(count.summary())) {
        js$enableTab('QC')
        js$enableTab('QC Table')
      }
    })

    observeEvent(input$countNormFile, {
      new.data <- read.delim(input$countNormFile$datapath)
      norm.counts(new.data)
      if (!is.null(norm.counts())) {
        js$enableTab('QC')
        js$enableTab('QC Table')
        updateSelectizeInput(session, 'bip.color', choices = c('', colnames(count.summary())), server = TRUE)
        updateSelectizeInput(session, 'bip.shape', choices = c('', colnames(count.summary())), server = TRUE)
      }
    })

    # Hide depmap tab if database not provided. Tried disable, still looks/feels selectable which may be confusing.
    if (is.null(depmap.db)) {
      shinyjs::hide(selector = '.navbar-nav a[data-value="DepMap"')
    }


    # -----------QC & QC Summary Tabs------------
    # PCA.

    pc <- reactive({
      req(norm.counts)
      req(count.summary)

      slmed <- norm.counts()
      slmat <- as.matrix(slmed[,c(-1,-2)])
      mat <- log2(slmat+1)
      rownames(mat) <- slmed$sgRNA

      req(input$var.remove)
      meta <- count.summary()

      # Filter samples from QC table.
      if (!is.null(input$count.summary_rows_all) & input$meta.filt) {
        meta <- count.summary()[input$count.summary_rows_all,]
        mat <- mat[,input$count.summary_rows_all]
      }

      rownames(meta) <- gsub("-", ".", meta$Label)

      # Remove guides with no variance in counts, as they break the PCA.
      mat <- mat[(rowMaxs(mat) - rowMins(mat) > 0),]

      # If input to use top N features instead rather than percent-based feature removal, account for that
      if (input$keep.top.n) {
        mat <- mat[order(rowVars(mat), decreasing = TRUE),]
        mat <- mat[1:input$var.n.keep,]
        var.remove <- 0
      } else {
        var.remove <- input$var.remove
      }

      if (ncol(mat) > 1) {

        pca(mat,
            metadata = meta,
            removeVar = var.remove,
            scale = input$scale,
            center = input$center)

      } else {
        NULL
      }
    })

    # Populate UI with all PCs.
    # TODO: Write check for only 2 PCs.
    output$pca.comps <- renderUI({
      req(pc)
      pcs <- pc()

      tagList(
        fluidRow(
          column(4, selectInput("dim1", "Dim1:", choices = pcs$components, selected = "PC1")),
          column(4, selectInput("dim2", "Dim2:", choices = pcs$components, selected = "PC2")),
          column(4, selectInput("dim3", "Dim3:", choices = pcs$components, selected = "PC3"))
        )
      )
    })

    output$qc.gini <- renderPlotly({
      gg <- BarView(count.summary(),
                    x = "Label",
                    y = "GiniIndex",
                    ylab = "Gini index",
                    main = "sgRNA Read Distribution")

      gg + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 12),
                 axis.text.y = element_text(size = 12))

      ggplotly(gg, tooltip = c("y")) %>%
        layout(yaxis = list(range = list(0, max(count.summary()$GiniIndex) + .05)),
               xaxis = list(tickangle = 315)) %>%
        config(toImageButtonOptions = list(format = "svg"),
               displaylogo = FALSE,
               plotGlPixelRatio = 7)
    })

    output$qc.missed <- renderPlotly({
      gg <- BarView(count.summary(), x = "Label", y = "Zerocounts", fill = "#394E80",
                    ylab = "Zero Count sgRNAs", main = "Fully Depleted sgRNAs")

      gg + theme_classic() + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 12),
                                   axis.text.y = element_text(size = 12)) + ylim(0, max(count.summary()$Zerocounts) + 5)

      ggplotly(gg, tooltip = c("y")) %>%
        layout(yaxis = list(range = list(0, max(count.summary()$Zerocounts) + 5)),
               xaxis = list(tickangle = 315)) %>%
        config(toImageButtonOptions = list(format = "svg"),
               displaylogo = FALSE,
               plotGlPixelRatio = 7)
    })

    output$qc.map <- renderPlot({
      MapRatesView(count.summary())
    })

    # TODO: rewrite this.
    observeEvent(norm.counts, {
      output$qc.histplot <- renderPlot({
        colors <- dittoColors()

        slmed <- norm.counts()
        tabsmat <- as.matrix(log2(slmed[,c(-1,-2)] + 1))
        colnames(tabsmat) <- colnames(slmed)[c(-1,-2)]
        samplecol <- colors[((1:ncol(tabsmat)) %% length(colors))]
        tgz <- hist(tabsmat, breaks = 40)

        if(ncol(tabsmat) >= 1) {
          histlist <- lapply(1:ncol(tabsmat), function(X) { return (hist(tabsmat[,X], plot=FALSE, breaks=tgz$breaks)) })
          xrange <- range(unlist(lapply(histlist, function(X) {X$mids})))
          yrange <- range(unlist(lapply(histlist, function(X) {X$counts})))
          hst1 <- histlist[[1]]
          plot(hst1$mids, hst1$counts, type='b', pch=20, xlim=c(0,xrange[2]*1.2),
               ylim=c(0,yrange[2]*1.2), xlab='log2(counts)', ylab='Frequency',
               main='Distribution of read counts', col = samplecol[1])
        }

        if(ncol(tabsmat) >= 2){
          for(i in 2:ncol(tabsmat)){
            hstn <- histlist[[i]]
            lines(hstn$mids, hstn$counts, type='b', pch=20, col=samplecol[i])
          }
        }

        legend('topright', colnames(tabsmat), pch=20, lwd=1, col=samplecol)
      })

      # TODO: rewrite this, add color min/max/mid selectors.
      output$qc.corr <- renderPlot({
        slmed <- norm.counts()
        slmat <- as.matrix(slmed[,c(-1,-2)])
        slmat.log <- log2(slmat+1)

        if (ncol(slmat.log) > 1){
          ComplexHeatmap::pheatmap(cor(slmat.log),
                                   heatmap_legend_param = list(title = "Pearson\nCorr."),
                                   main = "Correlation Matrix")
        } else {
          grid.newpage()
          grid.text("Only one sample, no correlation possible.")
        }

      })
    })

    observeEvent(pc, {
      output$qc.pca <- renderPlotly({
        req(pc, input$dim1, input$dim2, input$dim3)
        input$pca.update

        pc.res <- isolate(pc())

        pl.cols <- NULL
        pl.shapes <- NULL
        pl.col <- "black"
        hov.text <- NULL

        # Get marker aesthetics mappings.
        # Drop unused factor levels if possible.
        if (isolate(input$bip.color) != "") {
          pl.cols <- pc.res$metadata[,isolate(input$bip.color), drop = TRUE]
          if (is.factor(pl.cols)) {
            pl.cols <- droplevels(pl.cols)
          }
          pl.col <- dittoColors()[seq_along(unique(pc.res$metadata[,isolate(input$bip.color), drop = TRUE]))]
        }

        if (isolate(input$bip.shape) != "") {
          pl.shapes <- pc.res$metadata[,isolate(input$bip.shape), drop = TRUE]
          if (is.factor(pl.shapes)) {
            pl.shapes <- droplevels(pl.shapes)
          }
        }

        # Just throw label on hover for now.
        hov.text <- paste0("</br><b>Label:</b> ", pc.res$metadata$Label)

        # Check if 2D is wanted.
        if (isolate(input$bip.twod)) {
          fig <- plot_ly(pc.res$rotated,
                         x = as.formula(paste0("~", isolate(input$dim1))),
                         y = as.formula(paste0("~", isolate(input$dim2))),
                         type = "scatter",
                         mode = "markers",
                         marker = list(size = 15),
                         color = pl.cols,
                         colors = pl.col,
                         symbol = pl.shapes,
                         symbols = c("circle", "square", "diamond", "cross",
                                     "diamond-open", "circle-open", "square-open", "x"),
                         text = hov.text,
                         hoverinfo = "text") %>%
            layout(xaxis = list(showgrid = FALSE, showline = TRUE, mirror = TRUE, zeroline = FALSE,
                                title = paste0(isolate(input$dim1),
                                               " (", format(round(pc.res$variance[isolate(input$dim1)], 2), nsmall = 2),"%)")),
                   yaxis = list(showgrid = FALSE, showline = TRUE, mirror = TRUE, zeroline = FALSE,
                                title = paste0(isolate(input$dim2),
                                               " (", format(round(pc.res$variance[isolate(input$dim2)], 2), nsmall = 2),"%)")))

          fig <- fig %>% toWebGL()

          # Plot loadings.
          if (isolate(input$bip.loadings)) {
            lengthLoadingsArrowsFactor <- 1.5

            # Get number of loadings to display.
            xidx <- order(abs(pc.res$loadings[,isolate(input$dim1)]), decreasing = TRUE)
            yidx <- order(abs(pc.res$loadings[,isolate(input$dim2)]), decreasing = TRUE)
            vars <- unique(c(
              rownames(pc.res$loadings)[xidx][seq_len(isolate(input$bip.n.loadings))],
              rownames(pc.res$loadings)[yidx][seq_len(isolate(input$bip.n.loadings))]))

            # get scaling parameter to match between variable loadings and rotated loadings
            # This is cribbed almost verbatim from PCAtools code.
            r <- min(
              (max(pc.res$rotated[,isolate(input$dim1)]) - min(pc.res$rotated[,isolate(input$dim1)]) /
                 (max(pc.res$loadings[,isolate(input$dim1)]) - min(pc.res$loadings[,isolate(input$dim1)]))),
              (max(pc.res$rotated[,isolate(input$dim2)]) - min(pc.res$rotated[,isolate(input$dim2)]) /
                 (max(pc.res$loadings[,isolate(input$dim2)]) - min(pc.res$loadings[,isolate(input$dim2)]))))

            fig <- fig %>%
              add_segments(x = 0, xend = pc.res$loadings[vars,isolate(input$dim1)] * r * lengthLoadingsArrowsFactor,
                           y = 0, yend = pc.res$loadings[vars,isolate(input$dim2)] * r * lengthLoadingsArrowsFactor,
                           line = list(color = 'black'), inherit = FALSE, showlegend = FALSE, hoverinfo = "text") %>%
              add_annotations(x = pc.res$loadings[vars,isolate(input$dim1)] * r * lengthLoadingsArrowsFactor,
                              y = pc.res$loadings[vars,isolate(input$dim2)] * r * lengthLoadingsArrowsFactor,
                              ax = 0, ay = 0, text = vars, xanchor = 'center', yanchor= 'bottom')
          }
        } else {

          # Generate plot.
          fig <- plot_ly(pc.res$rotated, x = as.formula(paste0("~", isolate(input$dim1))),
                         y = as.formula(paste0("~", isolate(input$dim2))),
                         z = as.formula(paste0("~", isolate(input$dim3))),
                         type = "scatter3d",
                         mode = "markers",
                         color = pl.cols,
                         colors = pl.col,
                         symbol = pl.shapes,
                         symbols = c("circle", "square", "diamond", "cross", "diamond-open",
                                     "circle-open", "square-open", "x"),
                         text = hov.text,
                         hoverinfo = "text") %>%
            layout(scene = list(
              xaxis = list(title = paste0(isolate(input$dim1), " (",
                                          format(round(pc.res$variance[isolate(input$dim1)], 2), nsmall = 2),"%)")),
              yaxis = list(title = paste0(isolate(input$dim2), " (",
                                          format(round(pc.res$variance[isolate(input$dim2)], 2), nsmall = 2),"%)")),
              zaxis = list(title = paste0(isolate(input$dim3), " (",
                                          format(round(pc.res$variance[isolate(input$dim3)], 2), nsmall = 2),"%)")),
              camera = list(eye = list(x=1.5, y = 1.8, z = 0.4))))
        }
        fig <- fig %>%
          config(edits = list(annotationPosition = TRUE,
                              annotationTail = FALSE),
                 toImageButtonOptions = list(format = "svg"),
                 displaylogo = FALSE,
                 plotGlPixelRatio = 7)

        fig
      })
    })

    observeEvent(count.summary, {
      output$count.summary <- renderDT(server = FALSE, {
        DT::datatable(count.summary(),
                      rownames = FALSE,
                      filter = "top",
                      extensions = c("Buttons", "Scroller"),
                      options = list(
                        search = list(regex = TRUE),
                        lengthMenu = list(c(10, 25, 50, -1), c("10", "25", "50", "all")),
                        dom = 'Blfrtip',
                        buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                        scrollX = TRUE,
                        deferRender = TRUE,
                        scrollY = 600,
                        scroller = TRUE)
        ) %>% DT::formatStyle(0, target = "row", lineHeight = '80%')
      })
    })

    # Initialize plots by simulating button click once.
    o <- observe({
      req(pc, input$dim1, input$dim2, input$dim3)
      shinyjs::click("pca.update")
      o$destroy
    })

    #---------Gene (Overview) & Summary Tables Tabs-------------
    # Remove certain outputs if parameters for them are not provided.
    if (is.null(depmap.gene)) {
      shinyjs::hide("dep.crispr.ess")
      shinyjs::hide("dep.crispr.sel")
      shinyjs::hide("dep.rnai.ess")
      shinyjs::hide("dep.rnai.sel")
    }


    if (is.null(essential.genes)) {
      shinyjs::hide("rem.ess")
    }


    if (is.null(positive.ctrl.genes)) {
      shinyjs::hide("rem.pos")
    }


    # Disable certain inputs if only one dataset provided.
    observe({
      if (length(gene.data()) == 1) {
        shinyjs::disable("gene.sel2")
        shinyjs::hide("highlight.common")
      }
    })


    # Load the gene summaries for easy plotting.
    set1.genes <- reactive({
      df <- gene.data()[[input$gene.sel1]]
      .gene_ingress(df, sig.thresh = input$gene.fdr.th, lfc.thresh = input$gene.lfc.th,
                    positive.ctrl.genes = positive.ctrl.genes, essential.genes = essential.genes, depmap.genes = depmap.gene)
    })

    set2.genes <- reactive({
      if (length(gene.data()) > 1) {
        df <- gene.data()[[input$gene.sel2]]
        .gene_ingress(df, sig.thresh = input$gene.fdr.th, lfc.thresh = input$gene.lfc.th,
                      positive.ctrl.genes = positive.ctrl.genes, essential.genes = essential.genes, depmap.genes = depmap.gene)
      }
    })


    # Get overlapping hits between sets if needed.
    common.hits <- reactive({
      req(set1.genes, set2.genes)
      s1 <- set1.genes()
      s2 <- set2.genes()

      set1.hits <- s1$id[s1$hit_type %in% c("neg", "pos")]
      set2.hits <- s2$id[s2$hit_type %in% c("neg", "pos")]

      set1.hits[set1.hits %in% set2.hits]
    })

    # Keep track of which genes have been clicked
    clicked <- reactiveValues(volc1 = NULL, rank1 = NULL, lawn1 = NULL, volc2 = NULL, rank2 = NULL, lawn2 = NULL)

    # On click, the key field of the event data contains the gene symbol.
    # Add that gene to the set of all "selected" genes. Double click will clear all labels.
    # TODO: lapply this, probably.
    observeEvent(event_data("plotly_click", source = paste0(h.id,"_volc1")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_volc1"))
      gene_old_new <- rbind(clicked$volc1, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]

      if (nrow(keep) == 0) {
        clicked$volc1 <- NULL
      } else {
        clicked$volc1 <- keep
      }
    })

    observeEvent(event_data("plotly_click", source = paste0(h.id,"_rank1")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_rank1"))
      gene_old_new <- rbind(clicked$rank1, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]

      if (nrow(keep) == 0) {
        clicked$rank1 <- NULL
      } else {
        clicked$rank1 <- keep
      }
    })

    observeEvent(event_data("plotly_click", source = paste0(h.id,"_lawn1")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_lawn1"))
      gene_old_new <- rbind(clicked$lawn1, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]

      if (nrow(keep) == 0) {
        clicked$lawn1 <- NULL
      } else {
        clicked$lawn1 <- keep
      }
    })

    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_volc1")), {
      clicked$volc1 <- NULL
    })

    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_rank1")), {
      clicked$rank1 <- NULL
    })

    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_lawn1")), {
      clicked$lawn1 <- NULL
    })

    observeEvent(event_data("plotly_click", source = paste0(h.id,"_volc2")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_volc2"))
      gene_old_new <- rbind(clicked$volc2, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]

      if (nrow(keep) == 0) {
        clicked$volc2 <- NULL
      } else {
        clicked$volc2 <- keep
      }
    })

    observeEvent(event_data("plotly_click", source = paste0(h.id,"_rank2")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_rank2"))
      gene_old_new <- rbind(clicked$rank2, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]

      if (nrow(keep) == 0) {
        clicked$rank2 <- NULL
      } else {
        clicked$rank2 <- keep
      }
    })

    observeEvent(event_data("plotly_click", source = paste0(h.id,"_lawn2")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_lawn2"))
      gene_old_new <- rbind(clicked$lawn2, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]

      if (nrow(keep) == 0) {
        clicked$lawn2 <- NULL
      } else {
        clicked$lawn2 <- keep
      }
    })

    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_volc2")), {
      clicked$volc2 <- NULL
    })

    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_rank2")), {
      clicked$rank2 <- NULL
    })

    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_lawn2")), {
      clicked$lawn2 <- NULL
    })

    # Summary table and plots.
    output$gene1.summary <- renderDT({
      req(set1.genes)
      # Remove columns that are redundant or confusing.
      target <- which(names(set1.genes()) %in% c("neg|score", "neg|p-value", "neg|rank",
                                                 "neg|lfc", "pos|score", "pos|p-value", "pos|rank",
                                                 "pos|lfc", "RandomIndex", "Rank", "goodsgrna")) - 1

      df <- set1.genes()

      if (!is.null(common.hits)) {
        df$Overlap <- df$id %in% common.hits()
      }

      DT::datatable(df,
                    rownames = FALSE,
                    filter = "top",
                    extensions = c("Buttons"),
                    caption = paste0(input$gene.sel1, " Gene Summary"),
                    options = list(
                      search = list(regex = TRUE),
                      pageLength = 10,
                      dom = 'Blfrtip',
                      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                      columnDefs = list(list(visible = FALSE, targets = target)))
      ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
    })

    output$gene1.vol <- renderPlotly({
      req(set1.genes)
      input$vol.update

      df <- set1.genes()

      hov.info <- c("hit_type", "num", "goodsgrna")

      # Remove common essential genes if needed.
      if (isolate(input$rem.ess) & !is.null(df$essential)) {
        df <- df[!df$essential,]
      }

      # Remove positive control genes if needed.
      if (isolate(input$rem.pos) & !is.null(df$Positive_Control)) {
        df <- df[!df$Positive_Control,]
      }

      # Remove DepMap stuff if requested.
      if (!is.null(depmap.gene)) {
        if (isolate(input$dep.crispr.ess)) {
          df <- df[!df$DepMap_CRISPR_Essential,]
        }

        if (isolate(input$dep.crispr.sel)) {
          df <- df[!df$DepMap_CRISPR_Selective,]
        }

        if (isolate(input$dep.rnai.ess)) {
          df <- df[!df$DepMap_RNAi_Essential,]
        }

        if (isolate(input$dep.rnai.sel)) {
          df <- df[!df$DepMap_RNAi_Selective,]
        }
      }

      highlight <- NULL
      if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
        highlight.feats <- strsplit(input$hl.genes, ",|\\s|,\\s")[[1]]
        highlight <- highlight.feats[highlight.feats != ""]
      }

      # Add common hits to highlight.
      if (isolate(input$highlight.common)) {
        highlight <- unique(c(common.hits(), highlight))
      }


      .make_volcano(res = df,
                    xlim = isolate(input$vol.x),
                    ylim = isolate(input$vol.y),
                    fc.thresh = isolate(input$gene.lfc.th),
                    fc.lines = isolate(input$vol.fcline),
                    sig.thresh = isolate(input$gene.fdr.th),
                    sig.line = isolate(input$vol.sigline),
                    h.id = h.id,
                    h.id.suffix = "_volc1",
                    sig.term = "FDR",
                    lfc.term = "LFC",
                    feat.term = "id",
                    hover.info = hov.info,
                    fs = clicked$volc1,
                    up.color = isolate(input$up.color),
                    down.color = isolate(input$down.color),
                    insig.color = isolate(input$insig.color),
                    sig.opacity = isolate(input$sig.opa),
                    insig.opacity = isolate(input$insig.opa),
                    sig.size = isolate(input$sig.size),
                    insig.size = isolate(input$insig.size),
                    label.size = isolate(input$lab.size),
                    webgl = isolate(input$webgl),
                    webgl.ratio = isolate(input$webgl.ratio),
                    show.counts = isolate(input$counts),
                    show.hl.counts = isolate(input$hl.counts),
                    counts.size = isolate(input$counts.size),
                    highlight.featsets = isolate(input$hl.genesets),
                    highlight.feats = highlight,
                    featsets = genesets,
                    highlight.feats.color = isolate(input$hl.genes.col),
                    highlight.feats.size = isolate(input$hl.genes.size),
                    highlight.feats.opac = isolate(input$hl.genes.opa),
                    highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                    highlight.feats.linewidth = isolate(input$hl.genes.lw),
                    highlight.featsets.color = isolate(input$hl.genesets.col),
                    highlight.featsets.size = isolate(input$hl.genesets.size),
                    highlight.featsets.opac = isolate(input$hl.genesets.opa),
                    highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                    highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
    })

    output$gene1.rank <- renderPlotly({
      req(set1.genes)
      input$rank.update

      df <- set1.genes()

      hov.info <- c("hit_type", "num", "goodsgrna")

      # Remove common essential genes if needed.
      if (isolate(input$rem.ess) & !is.null(df$essential)) {
        df <- df[!df$essential,]
      }

      # Remove positive control genes if needed.
      if (isolate(input$rem.pos) & !is.null(df$Positive_Control)) {
        df <- df[!df$Positive_Control,]
      }

      # Remove DepMap stuff if requested.
      if (!is.null(depmap.gene)) {
        if (isolate(input$dep.crispr.ess)) {
          df <- df[!df$DepMap_CRISPR_Essential,]
        }

        if (isolate(input$dep.crispr.sel)) {
          df <- df[!df$DepMap_CRISPR_Selective,]
        }

        if (isolate(input$dep.rnai.ess)) {
          df <- df[!df$DepMap_RNAi_Essential,]
        }

        if (isolate(input$dep.rnai.sel)) {
          df <- df[!df$DepMap_RNAi_Selective,]
        }
      }

      highlight <- NULL
      if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
        highlight.feats <- strsplit(input$hl.genes, ",|\\s|,\\s")[[1]]
        highlight <- highlight.feats[highlight.feats != ""]
      }

      # Add common hits to highlight.
      if (isolate(input$highlight.common)) {
        highlight <- unique(c(common.hits(), highlight))
      }

      .make_rank(df = df,
                 ylim = list(isolate(input$rank.y.min), isolate(input$rank.y.max)),
                 y.thresh = isolate(input$gene.lfc.th),
                 y.lines = isolate(input$rank.fcline),
                 sig.thresh = isolate(input$gene.fdr.th),
                 h.id = h.id,
                 h.id.suffix = "_rank1",
                 sig.term = "FDR",
                 y.term = "LFC",
                 x.term = "Rank",
                 feat.term = "id",
                 hover.info = c("hit_type", "goodsgrna"),
                 fs = clicked$rank1,
                 up.color = isolate(input$up.color),
                 down.color = isolate(input$down.color),
                 insig.color = isolate(input$insig.color),
                 sig.opacity = isolate(input$sig.opa),
                 insig.opacity = isolate(input$insig.opa),
                 sig.size = isolate(input$sig.size),
                 insig.size = isolate(input$insig.size),
                 label.size = isolate(input$lab.size),
                 webgl = isolate(input$webgl),
                 webgl.ratio = isolate(input$webgl.ratio),
                 show.counts = isolate(input$counts),
                 show.hl.counts = isolate(input$hl.counts),
                 counts.size = isolate(input$counts.size),
                 highlight.featsets = isolate(input$hl.genesets),
                 highlight.feats = highlight,
                 featsets = genesets,
                 highlight.feats.color = isolate(input$hl.genes.col),
                 highlight.feats.size = isolate(input$hl.genes.size),
                 highlight.feats.opac = isolate(input$hl.genes.opa),
                 highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                 highlight.feats.linewidth = isolate(input$hl.genes.lw),
                 highlight.featsets.color = isolate(input$hl.genesets.col),
                 highlight.featsets.size = isolate(input$hl.genesets.size),
                 highlight.featsets.opac = isolate(input$hl.genesets.opa),
                 highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                 highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
    })

    output$gene1.lawn <- renderPlotly({
      req(set1.genes)
      df <- set1.genes()
      input$lawn.update

      hov.info <- c("hit_type", "num", "goodsgrna")

      # Remove common essential genes if needed.
      if (isolate(input$rem.ess) & !is.null(df$essential)) {
        df <- df[!df$essential,]
      }

      # Remove positive control genes if needed.
      if (isolate(input$rem.pos) & !is.null(df$Positive_Control)) {
        df <- df[!df$Positive_Control,]
      }

      # Remove DepMap stuff if requested.
      if (!is.null(depmap.gene)) {
        if (isolate(input$dep.crispr.ess)) {
          df <- df[!df$DepMap_CRISPR_Essential,]
        }

        if (isolate(input$dep.crispr.sel)) {
          df <- df[!df$DepMap_CRISPR_Selective,]
        }

        if (isolate(input$dep.rnai.ess)) {
          df <- df[!df$DepMap_RNAi_Essential,]
        }

        if (isolate(input$dep.rnai.sel)) {
          df <- df[!df$DepMap_RNAi_Selective,]
        }
      }

      highlight <- NULL
      if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
        highlight.feats <- strsplit(input$hl.genes, ",|\\s|,\\s")[[1]]
        highlight <- highlight.feats[highlight.feats != ""]
      }

      # Add common hits to highlight.
      if (isolate(input$highlight.common)) {
        highlight <- unique(c(common.hits(), highlight))
      }

      .make_lawn(res = df,
                 ylim = isolate(input$lawn.y),
                 fc.thresh = isolate(input$gene.lfc.th),
                 sig.thresh = isolate(input$gene.fdr.th),
                 sig.line = isolate(input$lawn.sigline),
                 h.id = h.id,
                 h.id.suffix = "_lawn1",
                 sig.term = "FDR",
                 lfc.term = "LFC",
                 feat.term = "id",
                 x.term = "RandomIndex",
                 hover.info = hov.info,
                 fs = clicked$lawn1,
                 up.color = isolate(input$up.color),
                 down.color = isolate(input$down.color),
                 insig.color = isolate(input$insig.color),
                 sig.opacity = isolate(input$sig.opa),
                 insig.opacity = isolate(input$insig.opa),
                 sig.size = isolate(input$sig.size),
                 insig.size = isolate(input$insig.size),
                 label.size = isolate(input$lab.size),
                 webgl = isolate(input$webgl),
                 webgl.ratio = isolate(input$webgl.ratio),
                 show.counts = isolate(input$counts),
                 show.hl.counts = isolate(input$hl.counts),
                 counts.size = isolate(input$counts.size),
                 highlight.featsets = isolate(input$hl.genesets),
                 highlight.feats = highlight,
                 featsets = genesets,
                 highlight.feats.color = isolate(input$hl.genes.col),
                 highlight.feats.size = isolate(input$hl.genes.size),
                 highlight.feats.opac = isolate(input$hl.genes.opa),
                 highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                 highlight.feats.linewidth = isolate(input$hl.genes.lw),
                 highlight.featsets.color = isolate(input$hl.genesets.col),
                 highlight.featsets.size = isolate(input$hl.genesets.size),
                 highlight.featsets.opac = isolate(input$hl.genesets.opa),
                 highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                 highlight.featsets.linewidth = isolate(input$hl.genesets.lw))

    })

    # If only one dataset provided, don't render second dataset.
    observe({if (length(gene.data()) > 1) {
      output$gene2.summary <- renderDT({
        req(set2.genes)
        # Remove columns that are redundant or confusing.
        target <- which(names(set2.genes()) %in% c("neg|score", "neg|p-value", "neg|rank",
                                                   "neg|lfc", "pos|score", "pos|p-value", "pos|rank",
                                                   "pos|lfc", "RandomIndex", "Rank", "goodsgrna")) - 1

        df <- set2.genes()

        # Label overlapping hits between datasets if available.
        if (!is.null(common.hits())) {
          df$Overlap <- df$id %in% common.hits()
        }

        DT::datatable(df,
                      rownames = FALSE,
                      filter = "top",
                      extensions = c("Buttons"),
                      caption = paste0(input$gene.sel2, " Gene Summary"),
                      options = list(
                        search = list(regex = TRUE),
                        dom = 'Blfrtip',
                        buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                        pageLength = 10,
                        columnDefs = list(list(visible = FALSE, targets = target)))
        ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
      })

      output$gene2.vol <- renderPlotly({
        req(set2.genes)
        input$vol.update

        df <- set2.genes()

        hov.info <- c("hit_type", "num", "goodsgrna")

        # Remove common essential genes if needed.
        if (isolate(input$rem.ess) & !is.null(df$essential)) {
          df <- df[!df$essential,]
        }

        # Remove positive control genes if needed.
        if (isolate(input$rem.pos) & !is.null(df$Positive_Control)) {
          df <- df[!df$Positive_Control,]
        }

        # Remove DepMap stuff if requested.
        if (!is.null(depmap.gene)) {
          if (isolate(input$dep.crispr.ess)) {
            df <- df[!df$DepMap_CRISPR_Essential,]
          }

          if (isolate(input$dep.crispr.sel)) {
            df <- df[!df$DepMap_CRISPR_Selective,]
          }

          if (isolate(input$dep.rnai.ess)) {
            df <- df[!df$DepMap_RNAi_Essential,]
          }

          if (isolate(input$dep.rnai.sel)) {
            df <- df[!df$DepMap_RNAi_Selective,]
          }
        }

        highlight <- NULL
        if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
          highlight.feats <- strsplit(input$hl.genes, ",|\\s|,\\s")[[1]]
          highlight <- highlight.feats[highlight.feats != ""]
        }

        # Add common hits to highlight.
        if (isolate(input$highlight.common)) {
          highlight <- unique(c(common.hits(), highlight))
        }


        .make_volcano(res = df,
                      xlim = isolate(input$vol.x),
                      ylim = isolate(input$vol.y),
                      fc.thresh = isolate(input$gene.lfc.th),
                      fc.lines = isolate(input$vol.fcline),
                      sig.thresh = isolate(input$gene.fdr.th),
                      sig.line = isolate(input$vol.sigline),
                      h.id = h.id,
                      h.id.suffix = "_volc2",
                      sig.term = "FDR",
                      lfc.term = "LFC",
                      feat.term = "id",
                      hover.info = hov.info,
                      fs = clicked$volc2,
                      up.color = isolate(input$up.color),
                      down.color = isolate(input$down.color),
                      insig.color = isolate(input$insig.color),
                      sig.opacity = isolate(input$sig.opa),
                      insig.opacity = isolate(input$insig.opa),
                      sig.size = isolate(input$sig.size),
                      insig.size = isolate(input$insig.size),
                      label.size = isolate(input$lab.size),
                      webgl = isolate(input$webgl),
                      webgl.ratio = isolate(input$webgl.ratio),
                      show.counts = isolate(input$counts),
                      show.hl.counts = isolate(input$hl.counts),
                      counts.size = isolate(input$counts.size),
                      highlight.featsets = isolate(input$hl.genesets),
                      highlight.feats = highlight,
                      featsets = genesets,
                      highlight.feats.color = isolate(input$hl.genes.col),
                      highlight.feats.size = isolate(input$hl.genes.size),
                      highlight.feats.opac = isolate(input$hl.genes.opa),
                      highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                      highlight.feats.linewidth = isolate(input$hl.genes.lw),
                      highlight.featsets.color = isolate(input$hl.genesets.col),
                      highlight.featsets.size = isolate(input$hl.genesets.size),
                      highlight.featsets.opac = isolate(input$hl.genesets.opa),
                      highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                      highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
      })

      output$gene2.rank <- renderPlotly({
        req(set2.genes)
        input$rank.update

        hov.info <- c("hit_type", "num", "goodsgrna")

        df <- set2.genes()

        # Remove common essential genes if needed.
        if (isolate(input$rem.ess) & !is.null(df$essential)) {
          df <- df[!df$essential,]
        }

        # Remove positive control genes if needed.
        if (isolate(input$rem.pos) & !is.null(df$Positive_Control)) {
          df <- df[!df$Positive_Control,]
        }

        # Remove DepMap stuff if requested.
        if (!is.null(depmap.gene)) {
          if (isolate(input$dep.crispr.ess)) {
            df <- df[!df$DepMap_CRISPR_Essential,]
          }

          if (isolate(input$dep.crispr.sel)) {
            df <- df[!df$DepMap_CRISPR_Selective,]
          }

          if (isolate(input$dep.rnai.ess)) {
            df <- df[!df$DepMap_RNAi_Essential,]
          }

          if (isolate(input$dep.rnai.sel)) {
            df <- df[!df$DepMap_RNAi_Selective,]
          }
        }

        highlight <- NULL
        if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
          highlight.feats <- strsplit(input$hl.genes, ",|\\s|,\\s")[[1]]
          highlight <- highlight.feats[highlight.feats != ""]
        }

        # Add common hits to highlight.
        if (isolate(input$highlight.common)) {
          highlight <- unique(c(common.hits(), highlight))
        }

        .make_rank(df = df,
                   ylim = list(isolate(input$rank.y.min), isolate(input$rank.y.max)),
                   y.thresh = isolate(input$gene.lfc.th),
                   y.lines = isolate(input$rank.fcline),
                   sig.thresh = isolate(input$gene.fdr.th),
                   h.id = h.id,
                   h.id.suffix = "_rank2",
                   sig.term = "FDR",
                   y.term = "LFC",
                   x.term = "Rank",
                   feat.term = "id",
                   hover.info = hov.info,
                   fs = clicked$rank2,
                   up.color = isolate(input$up.color),
                   down.color = isolate(input$down.color),
                   insig.color = isolate(input$insig.color),
                   sig.opacity = isolate(input$sig.opa),
                   insig.opacity = isolate(input$insig.opa),
                   sig.size = isolate(input$sig.size),
                   insig.size = isolate(input$insig.size),
                   label.size = isolate(input$lab.size),
                   webgl = isolate(input$webgl),
                   webgl.ratio = isolate(input$webgl.ratio),
                   show.counts = isolate(input$counts),
                   show.hl.counts = isolate(input$hl.counts),
                   counts.size = isolate(input$counts.size),
                   highlight.featsets = isolate(input$hl.genesets),
                   highlight.feats = highlight,
                   featsets = genesets,
                   highlight.feats.color = isolate(input$hl.genes.col),
                   highlight.feats.size = isolate(input$hl.genes.size),
                   highlight.feats.opac = isolate(input$hl.genes.opa),
                   highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                   highlight.feats.linewidth = isolate(input$hl.genes.lw),
                   highlight.featsets.color = isolate(input$hl.genesets.col),
                   highlight.featsets.size = isolate(input$hl.genesets.size),
                   highlight.featsets.opac = isolate(input$hl.genesets.opa),
                   highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                   highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
      })

      output$gene2.lawn <- renderPlotly({
        req(set2.genes)
        input$lawn.update

        hov.info <- c("hit_type", "num", "goodsgrna")

        df <- set2.genes()

        # Remove common essential genes if needed.
        if (isolate(input$rem.ess) & !is.null(df$essential)) {
          df <- df[!df$essential,]
        }

        # Remove positive control genes if needed.
        if (isolate(input$rem.pos) & !is.null(df$Positive_Control)) {
          df <- df[!df$Positive_Control,]
        }

        # Remove DepMap stuff if requested.
        if (!is.null(depmap.gene)) {
          if (isolate(input$dep.crispr.ess)) {
            df <- df[!df$DepMap_CRISPR_Essential,]
          }

          if (isolate(input$dep.crispr.sel)) {
            df <- df[!df$DepMap_CRISPR_Selective,]
          }

          if (isolate(input$dep.rnai.ess)) {
            df <- df[!df$DepMap_RNAi_Essential,]
          }

          if (isolate(input$dep.rnai.sel)) {
            df <- df[!df$DepMap_RNAi_Selective,]
          }
        }

        highlight <- NULL
        if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
          highlight.feats <- strsplit(input$hl.genes, ",|\\s|,\\s")[[1]]
          highlight <- highlight.feats[highlight.feats != ""]
        }

        # Add common hits to highlight.
        if (isolate(input$highlight.common)) {
          highlight <- unique(c(common.hits(), highlight))
        }

        .make_lawn(res = df,
                   ylim = isolate(input$lawn.y),
                   fc.thresh = isolate(input$gene.lfc.th),
                   sig.thresh = isolate(input$gene.fdr.th),
                   sig.line = isolate(input$lawn.sigline),
                   h.id = h.id,
                   h.id.suffix = "_lawn2",
                   sig.term = "FDR",
                   lfc.term = "LFC",
                   feat.term = "id",
                   x.term = "RandomIndex",
                   hover.info = hov.info,
                   fs = clicked$lawn2,
                   up.color = isolate(input$up.color),
                   down.color = isolate(input$down.color),
                   insig.color = isolate(input$insig.color),
                   sig.opacity = isolate(input$sig.opa),
                   insig.opacity = isolate(input$insig.opa),
                   sig.size = isolate(input$sig.size),
                   insig.size = isolate(input$insig.size),
                   label.size = isolate(input$lab.size),
                   webgl = isolate(input$webgl),
                   webgl.ratio = isolate(input$webgl.ratio),
                   show.counts = isolate(input$counts),
                   show.hl.counts = isolate(input$hl.counts),
                   counts.size = isolate(input$counts.size),
                   highlight.featsets = isolate(input$hl.genesets),
                   highlight.feats = highlight,
                   featsets = genesets,
                   highlight.feats.color = isolate(input$hl.genes.col),
                   highlight.feats.size = isolate(input$hl.genes.size),
                   highlight.feats.opac = isolate(input$hl.genes.opa),
                   highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                   highlight.feats.linewidth = isolate(input$hl.genes.lw),
                   highlight.featsets.color = isolate(input$hl.genesets.col),
                   highlight.featsets.size = isolate(input$hl.genesets.size),
                   highlight.featsets.opac = isolate(input$hl.genesets.opa),
                   highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                   highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
      }
      )
    }
    }
    )

    # If the Gene tab update button is pressed, click all the update buttons.
    observeEvent(input$gene.update, {
      shinyjs::click("lawn.update")
      shinyjs::click("vol.update")
      shinyjs::click("rank.update")
    })

    #---------------sgRNA Tab-----------------

    # Load the gene summaries for easy plotting.
    set1.sgrnas <- reactive({
      df <- sgrna.data()[[input$sgrna.sel1]]
      df$Rank <- rank(df$LFC)
      df
    })

    set2.sgrnas <- reactive({
      if (length(sgrna.data()) > 1) {
        df <- sgrna.data()[[input$sgrna.sel2]]
        df$Rank <- rank(df$LFC)
        df
      }
    })

    # Summary tables and plots.
    output$sgrna1.summary <- renderDT(server = FALSE, {
      req(set1.sgrnas)

      df <- set1.sgrnas()

      DT::datatable(df,
                    rownames = FALSE,
                    filter = "top",
                    extensions = c("Buttons"),
                    caption = paste0(input$sgrna.sel1, " sgRNA Summary"),
                    options = list(
                      search = list(regex = TRUE),
                      pageLength = 10,
                      dom = 'Blfrtip',
                      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'))
      ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
    })

    output$sgrna1.counts <- renderPlotly({
      req(set1.sgrnas, input$sgrna.gene)

      df <- set1.sgrnas()
      df <- df[df$Gene == input$sgrna.gene,]

      .make_sgrna_pairplot(df)
    })

    output$sgrna1.rank <- renderPlotly({
      req(set1.sgrnas)
      input$rank.update

      df <- set1.sgrnas()

      hov.info <- c("Gene")

      highlight <- NULL
      highlight <- df$sgrna[df$Gene == input$sgrna.gene]

      .make_rank(df = df,
                 ylim = list(min(df$LFC) - 0.5, max(df$LFC) + 0.5),
                 y.thresh = 0,
                 y.lines = FALSE,
                 sig.thresh = 0,
                 h.id = h.id,
                 h.id.suffix = "_sgrank1",
                 sig.term = "FDR",
                 y.term = "LFC",
                 x.term = "Rank",
                 feat.term = "sgrna",
                 hover.info = hov.info,
                 fs = NULL,
                 up.color = "#A6A6A6",
                 down.color = "#A6A6A6",
                 insig.color = "#A6A6A6",
                 sig.opacity = 1,
                 insig.opacity = 1,
                 sig.size = 5,
                 insig.size = 5,
                 label.size = 8,
                 webgl = TRUE,
                 webgl.ratio = 7,
                 show.counts = FALSE,
                 show.hl.counts = FALSE,
                 counts.size = 8,
                 highlight.featsets = NULL,
                 highlight.feats = highlight,
                 featsets = NULL,
                 highlight.feats.color = "red",
                 highlight.feats.size = 8,
                 highlight.feats.opac = 1,
                 highlight.feats.linecolor = "black",
                 highlight.feats.linewidth = 0.5,
                 highlight.featsets.color = "#A6A6A6",
                 highlight.featsets.size = 7,
                 highlight.featsets.opac = 1,
                 highlight.featsets.linecolor = "black",
                 highlight.featsets.linewidth = 0.5)
    })

    output$sgrna1.detail <- renderDT({
      req(set1.sgrnas, input$sgrna.gene)
      
      df <- set1.sgrnas()
      df <- df[df$Gene == input$sgrna.gene,]
      
      target <- which(names(df) %in% c("control_mean", "treat_mean", "control_var", "adj_var", "high_in_treatment", "p.low", "p.high", "p.twosided", "score")) - 1
      
      DT::datatable(df,
                    rownames = FALSE,
                    filter = "top",
                    extensions = c("Buttons"),
                    caption = paste0(input$sgrna.sel1, " ", input$sgrna.gene, " sgRNA Details"),
                    options = list(
                      pageLength = 10,
                      dom = 'Blfrtip',
                      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                      columnDefs = list(list(visible = FALSE, targets = target)))
      ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
    })

    observe({
      if (length(sgrna.data()) > 1) {
        output$sgrna2.summary <- renderDT(server = FALSE, {
          req(set2.sgrnas)
  
          df <- set2.sgrnas()
  
          DT::datatable(df,
                        rownames = FALSE,
                        filter = "top",
                        extensions = c("Buttons"),
                        caption = paste0(input$sgrna.sel2, " sgRNA Summary"),
                        options = list(
                          search = list(regex = TRUE),
                          pageLength = 10,
                          dom = 'Blfrtip',
                          buttons = c('copy', 'csv', 'excel', 'pdf', 'print'))
          ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
        })
  
        output$sgrna2.counts <- renderPlotly({
          req(set2.sgrnas, input$sgrna.gene)
  
          df <- set2.sgrnas()
          df <- df[df$Gene == input$sgrna.gene,]
  
          .make_sgrna_pairplot(df)
        })
  
        output$sgrna2.rank <- renderPlotly({
          req(set2.sgrnas)
          input$rank.update
  
          df <- set2.sgrnas()
  
          hov.info <- c("Gene")
  
          highlight <- NULL
          highlight <- df$sgrna[df$Gene == input$sgrna.gene]
  
          .make_rank(df = df,
                     ylim = list(min(df$LFC) - 0.5, max(df$LFC) + 0.5),
                     y.thresh = 0,
                     y.lines = FALSE,
                     sig.thresh = 0,
                     h.id = h.id,
                     h.id.suffix = "_sgrank1",
                     sig.term = "FDR",
                     y.term = "LFC",
                     x.term = "Rank",
                     feat.term = "sgrna",
                     hover.info = hov.info,
                     fs = NULL,
                     up.color = "#A6A6A6",
                     down.color = "#A6A6A6",
                     insig.color = "#A6A6A6",
                     sig.opacity = 1,
                     insig.opacity = 1,
                     sig.size = 5,
                     insig.size = 5,
                     label.size = 8,
                     webgl = TRUE,
                     webgl.ratio = 7,
                     show.counts = FALSE,
                     show.hl.counts = FALSE,
                     counts.size = 8,
                     highlight.featsets = NULL,
                     highlight.feats = highlight,
                     featsets = NULL,
                     highlight.feats.color = "red",
                     highlight.feats.size = 8,
                     highlight.feats.opac = 1,
                     highlight.feats.linecolor = "black",
                     highlight.feats.linewidth = 0.5,
                     highlight.featsets.color = "#A6A6A6",
                     highlight.featsets.size = 7,
                     highlight.featsets.opac = 1,
                     highlight.featsets.linecolor = "black",
                     highlight.featsets.linewidth = 0.5)
        })
  
        output$sgrna2.detail <- renderDT({
          req(set2.sgrnas, input$sgrna.gene)
  
          df <- set2.sgrnas()
          df <- df[df$Gene == input$sgrna.gene,]
  
          target <- which(names(df) %in% c("control_mean", "treat_mean", "control_var", "adj_var", "high_in_treatment", "p.low", "p.high", "p.twosided", "score")) - 1
  
          DT::datatable(df,
                        rownames = FALSE,
                        filter = "top",
                        extensions = c("Buttons"),
                        caption = paste0(input$sgrna.sel2, " ", input$sgrna.gene, " sgRNA Details"),
                        options = list(
                          pageLength = 10,
                          dom = 'Blfrtip',
                          buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                          columnDefs = list(list(visible = FALSE, targets = target)))
          ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
        })
      }
    })

    #--------------DepMap Tab-----------------
    if (!is.null(depmap.gene)) {
      output$depmap.deplines <- renderUI({
        req(input$depmap.gene, depmap.gene)
        dep.info <- get_depmap_essentiality(input$depmap.gene, depmap.gene)
        dep.release <- depmap::depmap_release()
        .make_dependency_tag(dep.info, dep.release)
      })
      # Dependency
      output$depmap.essplot <- renderPlotly({
        req(input$depmap.gene, depmap.meta)
        dep.info <- plot_depmap_dependency(input$depmap.gene, depmap.meta, pool)
      })
      # Expression
      output$depmap.expplot <- renderPlotly({
        req(input$depmap.gene, depmap.meta)
        dep.info <- plot_depmap_expression(input$depmap.gene, depmap.meta, pool)
      })
      # Copy number.
      output$depmap.cnplot <- renderPlotly({
        req(input$depmap.gene, depmap.meta)
        dep.info <- plot_depmap_cn(input$depmap.gene, depmap.meta, pool)
      })
    }
  }

  if (return.app) {
    shinyApp(ui, server)
  } else {
    return(list(ui = ui, server = server))
  }
}
